Learn 8 - Vector ArrayList LinkedList


Vector - java 早期 线程安全动态数组 （同步带来额外开销），容量自动增加时默认1倍

ArrayList - 动态数组，非线程安全，性能优异。容量自动增加时默认50%

LinkedList - 双向链表


Vector和ArrayList都是动态数组，内部以顺序存储。随机访问很高效。除了尾部意外， 其他位置插入和删除都需要移动整个后续数组

LinkedList 则进行节点插入删除要高效得多。但是随机访问性能不好

考察Java集合框架：
 - 其整体的设计结构
 - JAVA提供的主要容器（集合和Map），了解或掌握对应的数据结构和算法。思考具体技术选择
 - 扩展到性能和并发领域
 - 集合框架的演进和发展


经典算法：
 - 内部排序： 归并排序， 交换排序（冒泡，快排），选择排序， 插入排序
 - 外部排序： 利用内存和外部存储超大数据集 - 理解过程和思路

狭义的集合
 - List
 - Set
 - Queue

treeset 实际是 treemap 为基础而实现的
hashset 实际是 hashmap 为基础而实现的
 - TreeSet 支持自如按顺序访问，添加删除包含操作低效（logN）
 - HashSet利用哈希算法。理想状况下，哈希散列正常时可以提供常数时间的添加删除和包含操作。不保证有序
 - LinkedHashSet 内部构建了一个记录插入顺序的双线链表，提供了按插入顺序遍历的能力。保证了常熟时间的
   添加删除包含操作。略低于HashSet因为有额外的维护链表的开销
 - 遍历元素时，HashSet性能受自身容量影响。所以初始化时不要讲容量设置过大。对于LinkedHashSet，由于内部链表
   提供的方便，便利性能只和元素多少有关


排序算法
 - 原始数据类型： 早期是快速排序，现在是双轴快速排序（Dual-Pivot Quick Sort)
 - 对象数据类型： 目前使用TimSort （一种归并和二分插入排序），思路是合并已经排序好的分区（run）

演进
Java 8 引入了并行排序算法（Parallel Sort)利用现代多核处理器，底层基于fork-join实现。适用于大规模数据排序

更新的双轴快速排序

Java 8 引入了Lambda和Stream。部分接口有了默认实现方法
Java 9 提供了很多静态工厂方法，类似.of() 容量保证不可变形

Java支持可变参数Varargs，但是明显的额外开销。
